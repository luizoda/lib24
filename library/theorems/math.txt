Goldbach's: todo numero par n > 2 pode ser representado com n = a + b onde a e b sao primos
Twin prime: existem infinitos pares p, p + 2 onde ambos sao primos
Legendre's: sempre tem um primo entre n^2 e (n+1)^2
Lagrange's: todo numero inteiro pode ser inscrito como a soma de 4 quadrados
Zeckendorf's: todo numero pode ser representado pela soma de dois numeros de fibonnacis diferentes e nao consecutivos
Euclid's: toda tripla de pitagoras primitiva pode ser gerada com 
    (n^2 - m^2, 2nm, n^2+m^2) onde n, m sao coprimos e um deles eh par
Wilson's: n eh primo quando (n-1)! mod n = n - 1
Mcnugget: Para dois coprimos x, y o maior inteiro que nao pode ser escrito como ax + by eh (x-1)(y-1)/2

Fermat: Se p eh primo entao a^(p-1) % p = 1
Se x e m tambem forem coprimos entao x^k % m = x^(k mod(m-1)) % m
Euler's theorem: x^(phi(m)) mod m = 1 onde phi(m) eh o totiente de euler

Chinese remainder theorem: 
Para equacoes no formato x = a1 mod m1, ... , x = an mod mn onde todos os pares m1, ... , mn sao coprimos
Deixe Xk = m1*m2*..*mn/mk e Xk^-1 mod mk = inverso de Xk mod mk, entao
x = somatorio com k de 1 ate n de ak*Xk*(Xk,mk^-1 mod mk)
Para achar outra solucao so somar m1*m2*..*mn a solucao existente

Catalan number: exemplo expressoes de parenteses bem formadas
C0 = 1, Cn = somatorio de i=0 -> n-1 de Ci*C(n-1+1)
outra forma: Cn = (2n escolhe n)/(n+1)
Bertrand's ballot theorem: p votos tipo A e q votos tipo B com p>q, prob de em todo ponto ter mais As do que Bs antes dele = (p-q)/(p+q)
Se puder empates entao prob = (p+1-q)/(p+1), para achar quantidade de possibilidades nos dois casos basta multiplicar por (p + q escolhe q)
O número de caminhos de (0,0) até (n,n) que estão estritamente abaixo da diagonal y=x (mas podem tocar) em um grid é Catalan(n)

Propriedades de Coeficientes Binomiais:
Somatorio de k = 0 -> m de (-1)^k * (n escolhe k) = (-1)^m* (n -1 escolhe m)
(N escolhe K) = (N escolhe N-K)
(N escolhe K) = N/K * (n-1 escolhe k-1)
Somatorio de k = 0 -> n de (n escolhe k) = 2^n
Somatorio de m = 0 -> n de (m escolhe k) = (n+1 escolhe k + 1)
Somatorio de k = 0 -> m de (n+k escolhe k) = (n+m+1 escolhe m)
Somatorio de k = 0 -> n de (n escolhe k)^2 = (2n escolhe n)
Somatorio de k = 0 ou 1 -> n de k*(n escolhe k) = n * 2^(n-1)
Somatorio de k = 0 -> n de (n-k escolhe k) = Fib(n+1)

Hockey-stick: Somatorio de i = r -> n de (i escolhe r) = (n + 1 escolhe r + 1)
Vandermonde: (m+n escolhe r) = somatorio de k = 0 -> r de (m escolhe k) * (n escolhe r - k)

Burnside lemma: colares diferentes nao contando rotacoes quando m = cores e n = comprimento
(m^n + somatorio i =1 - > n-1 de m^gcd(i, n))/n

Distribuicao uniforme a,a+1, ..., b Expected[X] = (a+b)/2
Distribuicao binomial com n tentativas de probabilidade p, X = sucessos: 
    P(X = x) = p^x * (1-p)^(n-x) * (n escolhe x) e E[X] = p*n
Distribuicao geometrica onde continuamos ate ter sucesso, X = tentativas: 
    P(X = x) = (1-p)^(x-1) * p e E[X] = 1/p
Linearity of expectation: Tendo duas variaveis X e Y e constantes a e b, o valor esperado de aX + bY = a*E[X] + b*E[X]

(1 + x)^(-n) = somatorio( ( (-1)^k ) * ( (n + k - 1) escolhe k) * (x ^ k) ), k = 0 até k = inf

e >= log2(m)
n^e mod m == n^(phi(m) + (e mod phi(m)) mod m

phi(phi(...phi(m))) -> 1 em O(logM) iterações 

Seja T(k, i) = Quantas vezes o valor de V[1] aparece em "i" após fazer "k" somas de prefixo.
    T(k, i) = somatorio de j = 1 -> r de ((k + j - 1) escolhe(k - 1)) 

Multiplicative order: Smallest positive K such that a^k == 1 mod N -> ord_n(a)
As a consequence of Lagrange's theorem, ord_n(a) always divides φ(n) ( phi(n) )
Se gcd(a,n)!=1 não existe k>0 ^

Stirling Numbers:
S1(n,k) = numero de permutacoes com exatamente K ciclos
S1(n,k) = coefficient of x^k in the polynomial x*(x+1)(x+2)...(x+n-1) (can be found in Nlog^2 with FFT)
   S1(0, 0) = 1
   S1(n, 0) = 0 if n > 0
   S1(n, k) = 0 if k > n
   S1(n, k) = S1(n - 1, k - 1) + (n - 1) * S1(n - 1, k) # For unsigned
S2(n,k) = numero de particoes dos primeiros N inteiros em K conjuntos não vazios
   S2(n, 0) and S2(0, k) = 0 # for n, k > 0
   S2(n, n) = 1
   S2(n + 1, k) = k * S2(n, k) + S2(n, k - 1)
