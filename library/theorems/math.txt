Goldbach's: todo numero par n > 2 pode ser representado com n = a + b onde a e b sao primos
Twin prime: existem infinitos pares p, p + 2 onde ambos sao primos
Legendre's: sempre tem um primo entre n^2 e (n+1)^2
Lagrange's: todo numero inteiro pode ser inscrito como a soma de 4 quadrados
Zeckendorf's: todo numero pode ser representado pela soma de dois numeros de fibonnacis diferentes e nao consecutivos
Euclid's: toda tripla de pitagoras primitiva pode ser gerada com 
    (n^2 - m^2, 2nm, n^2+m^2) onde n, m sao coprimos e um deles eh par
Wilson's: n eh primo quando (n-1)! mod n = n - 1
Mcnugget: Para dois coprimos x, y o maior inteiro que nao pode ser escrito como ax + by eh (x-1)(y-1)/2

Fermat: Se p eh primo entao a^(p-1) % p = 1
Se x e m tambem forem coprimos entao x^k % m = x^(k mod(m-1)) % m
Euler's theorem: x^(phi(m)) mod m = 1 onde phi(m) eh o totiente de euler

Chinese remainder theorem: 
Para equacoes no formato x = a1 mod m1, ... , x = an mod mn onde todos os pares m1, ... , mn sao coprimos
Deixe Xk = m1*m2*..*mn/mk e Xk^-1 mod mk = inverso de Xk mod mk, entao
x = somatorio com k de 1 ate n de ak*Xk*(Xk,mk^-1 mod mk)
Para achar outra solucao so somar m1*m2*..*mn a solucao existente

Catalan number: exemplo expressoes de parenteses bem formadas
C0 = 1, Cn = somatorio de i=0 -> n-1 de Ci*C(n-1+1)
outra forma: Cn = (2n escolhe n)/(n+1)
Bertrand's ballot theorem: p votos tipo A e q votos tipo B com p>q, prob de em todo ponto ter mais As do que Bs antes dele = (p-q)/(p+q)
Se puder empates entao prob = (p+1-q)/(p+1), para achar quantidade de possibilidades nos dois casos basta multiplicar por (p + q escolhe q)
O número de caminhos de (0,0) até (n,n) que estão estritamente abaixo da diagonal y=x (mas podem tocar) em um grid é Catalan(n)

Propriedades de Coeficientes Binomiais:
Somatorio de k = 0 -> m de (-1)^k * (n escolhe k) = (-1)^m* (n -1 escolhe m)
(N escolhe K) = (N escolhe N-K)
(N escolhe K) = N/K * (n-1 escolhe k-1)
Somatorio de k = 0 -> n de (n escolhe k) = 2^n
Somatorio de m = 0 -> n de (m escolhe k) = (n+1 escolhe k + 1)
Somatorio de k = 0 -> m de (n+k escolhe k) = (n+m+1 escolhe m)
Somatorio de k = 0 -> n de (n escolhe k)^2 = (2n escolhe n)
Somatorio de k = 0 ou 1 -> n de k*(n escolhe k) = n * 2^(n-1)
Somatorio de k = 0 -> n de (n-k escolhe k) = Fib(n+1)

Hockey-stick: Somatorio de i = r -> n de (i escolhe r) = (n + 1 escolhe r + 1)
Vandermonde: (m+n escolhe r) = somatorio de k = 0 -> r de (m escolhe k) * (n escolhe r - k)

Burnside lemma: colares diferentes nao contando rotacoes quando m = cores e n = comprimento
(m^n + somatorio i =1 - > n-1 de m^gcd(i, n))/n

Distribuicao uniforme a,a+1, ..., b Expected[X] = (a+b)/2
Distribuicao binomial com n tentativas de probabilidade p, X = sucessos: 
    P(X = x) = p^x * (1-p)^(n-x) * (n escolhe x) e E[X] = p*n
Distribuicao geometrica onde continuamos ate ter sucesso, X = tentativas: 
    P(X = x) = (1-p)^(x-1) * p e E[X] = 1/p
Linearity of expectation: Tendo duas variaveis X e Y e constantes a e b, o valor esperado de aX + bY = a*E[X] + b*E[X]

(1 + x)^(-n) = somatorio( ( (-1)^k ) * ( (n + k - 1) escolhe k) * (x ^ k) ), k = 0 até k = inf

e >= log2(m)
n^e mod m == n^(phi(m) + (e mod phi(m)) mod m

phi(phi(...phi(m))) -> 1 em O(logM) iterações 

Seja T(k, i) = Quantas vezes o valor de V[1] aparece em "i" após fazer "k" somas de prefixo.
    T(k, i) = somatorio de j = 1 -> r de ((k + j - 1) escolhe(k - 1)) 

Multiplicative order: Smallest positive K such that a^k == 1 mod N -> ord_n(a)
As a consequence of Lagrange's theorem, ord_n(a) always divides φ(n) ( phi(n) )
Se gcd(a,n)!=1 não existe k>0 ^

Stirling Numbers:
S1(n,k) = numero de permutacoes com exatamente K ciclos
S1(n,k) = coefficient of x^k in the polynomial x*(x+1)(x+2)...(x+n-1) (can be found in Nlog^2 with FFT)
   S1(0, 0) = 1
   S1(n, 0) = 0 if n > 0
   S1(n, k) = 0 if k > n
   S1(n, k) = S1(n - 1, k - 1) + (n - 1) * S1(n - 1, k) # For unsigned
S2(n,k) = numero de particoes dos primeiros N inteiros em K conjuntos não vazios
   S2(n, 0) and S2(0, k) = 0 # for n, k > 0
   S2(n, n) = 1
   S2(n + 1, k) = k * S2(n, k) + S2(n, k - 1)

Sum of K powers - Educ 7 - F
O(min(N,K))
S(n,k) = sum i^k
P[i] = sum(j^k , 0<=j<=i).
S(n,k) = t * ((-1)^(k+1-i)) * (n-i)^-1 * finv[i] * finv[k+1-i] * p[i]
finv[i] -> 1/(1*2...*i) e t = (n*(n-1)...*(n-k-1))
Dá pra fazer com interpolação também...

Pisano:
k(m) = menor l tal que F[l] == 0 mod(m) && F[l+1]==1 mod(m) 
k(a*b) = lcm(k(a),k(b)) se gcd(a,b)=1
k(p^k) divide p^(k-1) * k(p)
k(5)=20,k(2)=3,k(3)=8
Se p>5:
k(p) divide (p-1) se p == +-1 mod 5
k(p) divide 2*(p+1) se p==+-2 mod 5

Diofantinas:
ax + by = c
divide tudo pelo gcd(a,b); se c%gcd(a,b)!=0, não tem solução
se não:
a' x + b' y = c' tem solução dada pelo algoritmo de euclides
a resposta do problema original é:
(X_g * c/g, Y_g * c/g), com X_g e Y_g achados com euclides.
OBS: passa abs(a) e abs(b) no euclides e depois inverter o sinal
se era negativo.

Toda solução é na forma
x = x0 + k * b'
y = y0 - k * a'
